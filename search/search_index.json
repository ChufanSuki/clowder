{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Clowder","text":""},{"location":"#components","title":"Components","text":"<ul> <li>Environment</li> <li>Actor</li> <li>Learner</li> <li>RPC</li> </ul>"},{"location":"actor/","title":"Actor","text":"<p><code>Actor</code> class interacts with a batch of <code>Environment</code>.</p>"},{"location":"environment/","title":"Environment Design","text":"<p>The main interaction with the <code>environment</code> is via the <code>step()</code> method. Each call to an environment's <code>step()</code> method takes an <code>action</code>(a_t) returns a <code>TimeStep</code> namedtuple with fields <code>step_type, reward, discount, observation</code>.</p> <p>Environments should return observations and accept actions in the form of <code>NestedArray</code>. Each environment also implements an <code>observation_spec()</code> and an <code>action_spec()</code> method. Each method should return a structure of Array specs <code>NestedSpec</code>, where the structure should correspond exactly to the format of the actions/observations.</p>"},{"location":"environment/#compatibility","title":"Compatibility","text":"<p>We <code>dm_env.Environment</code> class but it should be compatible with <code>Gymnasium</code>. We provide a wrapper class to convert <code>Gymnasium.Environment</code> to <code>dm_env.Environment</code>.</p>"},{"location":"environment/#environment-pool","title":"Environment Pool","text":"<p><code>EnvPool</code> is a class that manages a pool of environments. It is useful for parallelizing the interaction with the environment. It is also useful for managing multiple environments with different configurations.</p>"},{"location":"rpc/","title":"RPC","text":"<p>Actors, Learners, Environments may distributed across processes and machines. We use RPC to communicate between these processes. We try to make this deep learning framework agnostic. </p> <p>An <code>RPC</code> object calls remote function or accepts remote function from other <code>RPC</code> object. In convention, we call the caller <code>client</code> and the callee <code>server</code>. Because the <code>server</code> <code>RPC</code> object provides a remote function to be called, it also has the name <code>service</code>.</p> <p></p>"},{"location":"rpc/#launchable","title":"Launchable","text":"<p><code>Launchable</code> is a interface that defines <code>init_launcher</code> and <code>init_execution</code> methods.</p>"},{"location":"rpc/#remotable","title":"Remotable","text":"<p><code>RemotableMeta</code> is a metaclass that automatically mark methods in a class as remote functions if they have the <code>__remote__</code> attribute set to True, and collects all remote method names into a list in the <code>__remote_methods__</code> attribute of the class. It creates a set called <code>remote_methods</code> and populates it with any methods defined in the <code>__remote_methods__</code> attribute in the class and any of its base classes. Any method has the <code>__remote__</code> attribute set to <code>True</code> also be added to the set.</p>"},{"location":"rpc/#worker","title":"Worker","text":"<p><code>Worker</code> is an interface for (potentially) distributed workers. Each worker is a subprocess.</p> <pre><code>class SimpleWorker(Worker):\ndef run(self):\nprint(\"Meow, \ud83d\ude3b\")\nworker = Worker()\nworker.start() # spwan a subprocess with target=run\n</code></pre>"},{"location":"rpc/#handle","title":"Handle","text":"<p><code>Handle</code> is an interface for <code>Worker</code>. <code>handle.dereference()</code> will return the worker object. We mainly use the handle to call remote functions on another worker.</p>"}]}